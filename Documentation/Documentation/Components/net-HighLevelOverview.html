<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta charset="utf-8" />
<!-- #TemplateBeginEditable name="doctitle" -->		<title>Unity - High Level Networking Concepts</title>
<!-- #TemplateEndEditable -->		<link href="../Images/docs.css" rel="StyleSheet" type="text/css" />
	</head>
	<body onload="DocLoaded();">
		<table border="0" cellpadding="0" cellspacing="0" class="titlebar">
			<tbody>
				<tr>
					<td class="titleleft">
						<img src="../images/top/left.png" /></td>
					<td>
						<a href="../../Documentation.html"><img src="../images/top/logo.png" /></a></td>
					<td class="titlemid">
						<table>
							<tbody>
								<tr>
									<td class="doctitle">
										ハイレベルネットワークキングの概要</td>
									<td>
										<table align="right">
											<tbody>
												<tr>
<!-- #TemplateBeginEditable name="sections-nav" -->													<td class="Components">
														<a class="scripting-anchor" href="../Manual/index.html" title="Go to Unity manual"><img border="0" class="manual" src="../images/spacer.gif" /><span class="manual-text">Manual</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
													<td class="Components">
														<a class="scripting-anchor" href="../Components/index.html" title="Go to Reference"><img border="0" class="reference" src="../images/spacer.gif" /><span class="components-text">Reference</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
													<td class="Components">
														<a class="scripting-anchor" href="../ScriptReference/index.html" title="Go to Scripting Reference"><img border="0" class="scripting" src="../images/spacer.gif" /><span class="scripting-text">Scripting &nbsp;&nbsp;</span></a></td>
<!-- #TemplateEndEditable -->												</tr>
											</tbody>
										</table>
									</td>
								</tr>
								<tr>
									<td colspan="4">
										<table class="docpath" width="100%">
											<tbody>
												<tr>
													<td>
														<a href="../Components/index.html">リファレンスマニュアル</a> &gt; <a href="../Components/net-HighLevelOverview.html">ハイレベルネットワークキングの概要</a><!-- #TemplateEndEditable --></td>
													<td class="switchlink">
<!-- #TemplateBeginEditable name="switchLink" --><!--BeginSwitchLink--><!--EndSwitchLink--><!-- #TemplateEndEditable -->													</td>
												</tr>
											</tbody>
										</table>
									</td>
								</tr>
							</tbody>
						</table>
					</td>
					<td class="titleright" width="9">
						<img src="../images/top/right.png" /></td>
				</tr>
			</tbody>
		</table>
		<div class="manual">
			<div class="main">
<!-- #TemplateBeginEditable name="unofficial translation" -->
<div id="unofficial_translation"><center><table border="1" ><tr><td  bgcolor="yellow"><center>このドキュメントは有志により翻訳されたもので、オフィシャルではありません。オリジナルのページは<a href="http://unity3d.com/support/documentation/" target="_blank">こちら</a>。<br>This document is unofficially translated by users.Please see the original document <a href="http://unity3d.com/support/documentation/" target="_blank">here</a>.<br><br>翻訳に関する修正など、ご連絡は<a href="mailto:stagesp1@gmail.com">こちら</a>まで。<br>Please send e-mail to <a href="mailto:stagesp1@gmail.com">here</a>, when you have any question about the translation.</center></td>
<td><a href="https://github.com/shinobushiva/unity3ddocsj"><img src="../Images/pencil.png"/></a><br/>編集 (GitHub)</td>
</tr></table></center></div>
<!-- #TemplateEndEditable -->

<!-- #TemplateBeginEditable name="navigation" -->				<div class="nav">
					<div class="nav-prev">
						<a href="../Components/Networking on iOS.html"> </a>
						<div class="nav-left">
							&nbsp;</div>
						<div class="nav-main">
							<a href="../Components/Networking on iOS.html">戻る</a></div>
						<div class="nav-right">
							&nbsp;</div>
					</div>
					<div class="nav-next">
						<a href="../Components/net-UnityNetworkElements.html"> </a>
						<div class="nav-left">
							&nbsp;</div>
						<div class="nav-main">
							<a href="../Components/net-UnityNetworkElements.html">次へ</a></div>
						<div class="nav-right">
							&nbsp;</div>
					</div>
				</div>
<!-- #TemplateEndEditable --><!-- #TemplateBeginEditable name="title" -->				<h1>
					ハイレベルネットワークキングの概要</h1>
<!-- #TemplateEndEditable --><!-- #TemplateBeginEditable name="body" -->				<p>
					以下の情報は、ネットワークを利用したゲーム全てに関連する概念であり、Unity固有の概念というわけではありません。あなたがUnityのネットワーク利用を実装する前に、これらの概念を理解することはとても有用なことです。</p>
				<h2>
					ネットワーキングとは何か？</h2>
				<p>
					ネットワーキングの基本的は概念は、複数のコンピューター間での通信です。通信には、<strong>クライアント</strong>と<strong>サーバー</strong>の２つが必要となります。サーバーは、固定のホストマシンを設定するか、他のプレイヤーのために特定のプレイヤーをホストとして設定するかのどちらかを選ぶことができます。サーバーが確立され、それにクライアントが接続された時、マルチプレイヤーネットワークゲームに必要なデータをコンピューター間で交換することができます。</p>
				<p class="vspace">
					ネットワークゲームを作成すると、細部に対し非常に多くの注意が必要となります。ほとんどの設計や作成が容易であるUnityにおいてもネットワーキングは非常に複雑なままです。なぜなら我々は非常に堅牢で柔軟なUnityのネットワークを構築することを選んだからです。これは、ゲームクリエーターとしてあなたが普通は考える必要のない選択肢についても多数選択を行う必要性が出てくるということです。これらの選択肢は、ゲームをビルドする方法に大きな影響を与えることになるので、できるだけ簡単に作成しておくことが必要です。これらの概念を学習し、長期的視点で考え、事前に出来る限りの計画を立てる必要があります。</p>
				<h2>
					ネットワーキングのアプローチ</h2>
				<p>
					ネットワークゲームを構成するには２つの一般的で実績のある方式があります。これらの方式は<strong>Authoritative Server（権限のあるサーバー）</strong>と<strong>Non-Authoritative Server（権限の無いサーバー）</strong>と呼ばれます。どちらの方式もクライアントがサーバーに接続し、情報の受け渡しを行います。さらにエンドユーザーがプライバシーを要求する場合、クライアント間の直接の通信や他のクライアントへIPアドレスの公開を行いません。</p>
				<h3>
					Authoritative Server（権限のあるサーバー）</h3>
				<p>
					この方式では、サーバーがすべてのシミュレーション、ルールの適用、プレイヤーの入力処理を行います。それぞれのクライアントはサーバーに入力（キー入力や関数の呼び出し）を送信し、断続的にサーバーからゲームの現在の状況を受け取ります。クライアント自身がゲームロジックを変更することはありません。その代りに、何を行いたいのかをサーバーに伝えることでサーバーが内部ロジックの処理を行い、何が起きたのかを正確にクライアントへと通知します。</p>
				<p class="vspace">
					基本的に、これはプレイヤーが何を行いたいかと言う要望と実際何が起こったのかと言う結果を分けて扱います。サーバーはそれぞれが何をしたいのかを聞き、ゲームのルール（これはゲームごとに異なる）に合わせ、ロジックを適用することでクライアントに対し、何をする必要があるのかを指示します。これは&rdquo;プレイヤーが何をしたいのかを通知する。&rarr;サーバーは何が起こるかを決定する。&rarr;サーバーはクライアントに更新情報を通知する&rdquo;と考えることができます。</p>
				<p class="vspace">
					この方式を利用する利点として、クライアントの不正を困難にすることができます。例えば、各クライアントはネットワーク通信技術の限界により「私はあなたのキャラクターを殺害しました。」とサーバー（または他のすべてのクライアント）に対して通知を行う権限を所持してはいません。彼らは「私は武器を使用しました。」と通知することはできますが、殺害が行われたかどうかはサーバーによって決定されます。</p>
				<p class="vspace">
					具体的な例えとして、この方式でゲーム内の物理方式の適用を&rdquo;プレイヤークライアントはサーバーに入力を送信&rarr;サーバーは物理シミュレーションにより衝突判定や効果を決定&rarr;サーバーはプレイヤークライアントに対し、オブジェクトの位置情報の更新を通知&rdquo;と表すことができます。これは各プレイヤークライアントが完全な物理シミュレーションを行っているように見える一方で、実際はそうでないことを意味しています。実際にはサーバーによって実行されたシミュレーション結果を受け取っているだけなのです。</p>
				<p class="vspace">
					この方式で、ローカルでの動作はサーバーに通信が到達するまでの間効果が無いため、プレイヤーにとっては不自然見えることがあるでしょう。例えばキャラクターを前進させたい場合、クライアントとサーバー間での通信に50m秒必要ならば通信の往復にかかる100m秒の間、キャラクターへの動作が適用されないことになります。これを防ぐために<strong>Client Side Prediction（クライアントサイド予測）</strong>と呼ばれる方式が用いられます。これは非常に専門的で高度な技術であるため、このガイドでの詳しい説明は行いません。しかし単純に説明すると、各クライアントがそれぞれの予測をもとに結果が送信されて来る前に各自で動作を行い、そこに間違いが生じた場合はサーバーより送られてきた結果を上書きし、訂正するというものです。詳しく知りたい場合はGoogleで検索してみると良いでしょう。</p>
				<p class="vspace">
					この方式を使用する際には、サーバーに対する負荷が増大します。アクションゲームにおいて、32人の異なるプレイヤーがそれぞれ異なる要求や操作を実行した場合のサーバーの状態についてイメージしてみてください。その時サーバーはユーザーの入力に対し、何が正しく何が正しくないのかを判別し、クライアント間の衝突を解決する必要があるのです。</p>
				<h3>
					Non-Authoritative Server（権限の無いサーバー）</h3>
				<p>
					この方式では、ユーザーの入力に対して制御を行いません。クライアント自身がユーザーのインプットに対するロジック処理を行い、その結果をサーバーに対し送信します。サーバーは全てのアクションを世界で同期します。これはデザインに観点から実装する方が簡単で、クライアント間で実際メッセージの中継を行いますがクライアントが実行すること以上の余分な処理は行いません。</p>
				<p class="vspace">
					サーバーは、クライアントが全て物理現象やイベント自体決定し、サーバーに何が起こったのか通知するので行動予測を行う必要がありません。彼らはオブジェクトの所有者であり、唯一ネットワーク内のオブジェクトをローカルに変更できるよう指示することができます。</p>
				<h2>
					ネットワークの通信方法</h2>
				<p>
					今までネットワークゲームの基本的なアーキテクチャを取り上げてきたので、次はクライアントとサーバーが相互にローレベルでの通信を行う方法について検討します。</p>
				<p class="vspace">
					<strong>リモートプロシージャコール</strong>と<strong>状態の同期</strong>と言う２つの関連するメソッドがあります。これは、特定のゲームで両方とも使用されることも稀ではありません。</p>
				<h3>
					リモートプロシージャコール（RPC）</h3>
				<p>
					リモートプロシージャコールは、ネットワークを介して異なるマシン上で機能を呼び出すために使用されます。これは、同様にプレイヤーのローカルゲームのインスタンスを含めることができます。クライアントはRPCをサーバーに送信すすることができ、サーバーは複数のクライアントにRPCを送信することができます。一般的に、これはまれに起こるアクションに使われます。例えば、クライアントがドアを開けるためのスイッチを押したとして、サーバーにドアが開かれたことを通知するRPCを送信することができます。そしてそれは個々のイベントを管理及び実行するために使用されます。</p>
				<h3>
					状態の同期</h3>
				<p>
					状態の同期は絶えず変化するデータを共有するために使用されます。この最も解りやすい例として、アクションゲームでのプレイヤーの位置があります。プレイヤーは常に歩く、走る、ジャンプ等の行動を行っています。ローカルでこのプレイヤーを操作していないネットワーク内の全てのプレイヤーも、このプレイヤーの位置と行動を把握する必要があります。このプレイヤーの位置を常に中継することにより、その位置を正確に他のプレイヤーも表示することができるのです。</p>
				<p class="vspace">
					この種のデータは頻繁に、そして定期的ネットワーク経由で送信されます。このデータは時間に敏感であり、マシン間をインターネットの配線を渡って移動する時間を必要とするので可能な限り送信されるデータ量を最少に抑えることが重要となってきます。単純に言って、状態の同期が自然と多くの帯域幅を必要とするので、あなたはできる限り帯域幅の利用を最少に抑えられるところは抑える必要があります。</p>
				<h3>
					サーバーとクライアントを接続する</h3>
				<p>
					全ての変数を考慮しなければならない場合、サーバーとクライアントを接続することは複雑なテーマとなります。マシンはプライベートまたはパブリックIPを持つことができ、ローカルまたは外部のアクセスをブロックするファイアウォールを持つことができます。Unityネットワークは、全ての状況を処理するメソッドを提供しようとしていますが、これの為の魔法のボタンは存在しません。</p>
				<p class="vspace">
					プライベートアドレスはインターネットから直接アクセスできないIPアドレスであり、これらはインターネットに接続するために用意られるためNAT（Natwork Address Translation）と呼ばれます。大まかにこれを説明すると、プライベートアドレスはパブリックアドレスにアドレスを変換するため、いくつかのローカルルーターを経由します。この方法では、プライベートアドレスの大多数はインターネットと通信するための単一のパブリックIPアドレスを使用することができます。これはインターネットから誰かがプライベートアドレスとの接触を開始しようとするまでは最善です。プライベートアドレスを処理するためルータのパブリックアドレスを経由する必要があり、NATパンチスルーと呼ばれる概念を除いてこれを行う方法はありません。NATパンチスルーと一般的なサーバーがパブリックアドレスとプライベートアドレスを接続できるように仲介するものをファシリテーターと呼びます。これはファシリテーターと最初に接続してプライベートアドレスをファシリテーターに最初に接続することにより、ローカルルータを通して穴をあけます。ファシリテーターは、現在プライベートアドレスが使用しているパブリックIPアドレスとポートを見ることができます。この情報を使用して、インターネット上のどのマシンでも以前接続不可能だったプライベートアドレスへと直接接続することができるようになります。これは基本をカバーするために簡略化して説明してあるということをご了承ください。</p>
				<p class="vspace">
					パブリックアドレスはもっと単純です。ここでの主な危険性はその接続が内部、または外部のファイアウォールにより遮断される恐れがあることです。内部のファイアウォールはマシン上でローカルに実行されているファイアウォールとして解釈されます。この場合、ユーザーはゲームサーバーにポートを解放するよう要求することが出来ます。外部ファイアウォールはネットワークやルータ上で動作するファイアウォール、またはユーザーの制御外にある似たようなものとして認識されます。この場合、ファイアウォールに穴を開けるためNATパンチスルー方式を使用する以外に接続方法については言うことが無いかもしれません。テストの間、これは動作を行いましたがこれがどのようにして成功しているのかを示すのに利用できる研究はありません。</p>
				<p class="vspace">
					上記の接続問題は、他のサーバーおよびクライアントに影響を与えます。クライアントはトラフィックを発信し、素早い通信を必要とするサーバーよりは単純です。クライアントは大抵の動作を行えるパブリックアドレスを所持している場合、非常にアクセス制限の厳しい企業のネットワーク上以外でのトラフィックの発信が妨害されることはありません。クライアントがプライベートアドレスを持つ場合、NATパンチスルーを使用することのできないプライベートアドレスを持つサーバーを除くすべてのサーバーにアクセスできます。これらの詳細は後に記載します。未知のソースからの接続を受け入れる必要があるサーバーでは、これはより複雑になります。パブリックアドレスを持つサーバーは、ファイアウォールによってブロックされないためにインターネットへゲームポートを解放する必要があります。もしポートが閉じていてインターネットへアクセス可能な場合、クライアントはサーバーからの接続を受け入れ、使用することが出来ません。サーバーがプライベートアドレスを持つ場合、誰も接続することが出来なくなるのを防ぐためNATパンチスルーを実行できる必要があります。NATパンチスルーを使用できないクラインとはサーバーに接続できなくなります。</p>
				<p class="vspace">
					Unityはこれらすべての異なる接続状況をテストするツールを提供しています。すべてが解決し、サーバーとクライアントが接続を始めたい場合、２つのことを知る必要があります。クライアントが直接接続するためにサーバーがマスターサーバーからの助けを借りる場合のDNS名、もしくはIPアドレスです。マスターサーバーは、サーバーがクライアントにその存在をアドバタイズすることが出来ます。その場合、クライアントは事前にすべてのサーバーについて知る必要はありません。&nbsp;</p>
				<h2>
					ネットワーク帯域幅の最小化</h2>
				<p>
					複数のクライアント間の状態の同期を行う場合、必ずしもオブジェクトを同期表示させるため、一つ一つを詳細に同期する必要はありません。例えば、キャラクターのアバターを同期する場合、クライアント間でその位置と動作を送信する必要があります。例え性格そのものが非常に複雑で、深いトランスフォーム階層が含まれるとしても、階層全体についてのデータを共有する必要はありません。</p>
				<p class="vspace">
					あなたのゲーム内の多くのデータは静的に見られ、クライアントはこれを移したり同期する必要はありません。遠くの、もしくはある時のRPCを呼び出したい場合、あんたは多くの機能を働かせるのに十分でなければならない。あなたのゲームのすべてのインストールでは、存在がわかっているデータを活用し、クライアントは可能な限り自力でそれを動かす必要があります。例えば、テクスチャやメッシュのようなアセットがすべてのインストールに存在し、それらは普通変化しないということをあなたは知っています。したがって、それらを同期する必要はありません。わかりやすい例えで、あなたは一人のクライアントが他のクライアントとデータを共有するとき何が重要だと考えるでしょう。それはあなたが共有すべきデータのみです。</p>
				<p class="vspace">
					これは以前ネットワークゲームを作成したことが無い場合は特に容易なことではありません。すべてのクライアントに全体の指定されたレベルをロードして、それら自身のネットワークでつながれた要素を自動的に加えさせるのにあなたはローレベルネームによるただ一つのRPC呼び出しを使用できるという点を考慮してください。各クライアントが可能な限り自給自足するようにゲームを構成することで、帯域幅の使用を最小限に抑えられるでしょう。</p>
				<h2>
					マルチプレイヤーゲームのパフォーマンス</h2>
				<p>
					サーバー自体の物理的位置と性能はその上で動作するゲームの動作性に影響を与える可能性があります。サーバーから離れた位置に存在するクライアントには、大きなタイムラグが発生する恐れがあります。それは仕方ないことであり、私たちに出来ることは実際何もありません。サーバーのハードウェアがどれだけ充実していようとも、データのやり取りに必要な距離が処理の遅れの原因となってしまいます。サーバーとクライアントが近い位置に位置するのであれば問題はありませんが。</p>
				<h2>
					おまけ</h2>
				<p>
					ネットワークの概念を学習するのに役立つリンクを集めておきました。可能な限り多くのネットワークリソースを読むことをお勧めします。</p>
				<ul>
					<li>
						<a class="urllink" href="http://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking" rel="nofollow">http://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking</a></li>
					<li>
						<a class="urllink" href="http://developer.valvesoftware.com/wiki/Lag_Compensation" rel="nofollow">http://developer.valvesoftware.com/wiki/Lag_Compensation</a></li>
					<li>
						<a class="urllink" href="http://developer.valvesoftware.com/wiki/Working_With_Prediction" rel="nofollow">http://developer.valvesoftware.com/wiki/Working_With_Prediction</a></li>
					<li>
						<a class="urllink" href="http://www.gamasutra.com/resource_guide/20020916/lambright_01.htm" rel="nofollow">http://www.gamasutra.com/resource_guide/20020916/lambright_01.htm</a></li>
				</ul>
				<p>
					&nbsp;</p>
				<small>Page last updated: 2010-07-19</small>
				<p>
					&nbsp;</p>
<script type="text/javascript">


    var allHTMLTags = new Array();
    document.divs = new Array();

    function getElementByClass(theClass) {

	    var allHTMLTags=document.getElementsByTagName("*");

	    for (var i=0; i<allHTMLTags.length; i++) {

		    if (allHTMLTags[i].className==theClass) {
			    return true;
		    }
	    }
	    return false;
    }

    function ShowHideDiv(containerName, className, content){
	var container = document.getElementById(containerName);
	if(container == null)
		return;
	if(content == '') {//In case there are no divs in the page we still can change the icons.
		if(containerName == 'desktopRef') {
			if(container.innerHTML == "<img src="../Images/DesktopNO.png" alt="">") {
				container.innerHTML = "<img src="../Images/DesktopYES.png" alt="">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src="../Images/DesktopNO.png" alt="">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'iosRef') {
			if(container.innerHTML == "<img src="../Images/iPhoneNO.png" alt="">") {
				container.innerHTML = "<img src="../Images/iPhoneYES.png" alt="">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src="../Images/iPhoneNO.png" alt="">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'androidRef') {
			if(container.innerHTML == "<img src="../Images/AndroidNO.png" alt="">") {
				container.innerHTML = "<img src="../Images/AndroidYES.png" alt="">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src="../Images/AndroidNO.png" alt="">";
				UnSetCookie(containerName);
			}	
		}
	} else {
		if(container.innerHTML == "<h1><img src="../Images/PlatformArrowRight.png" alt=""> " + content + "</h1>") {
		container.innerHTML = "<h1><img src="../Images/PlatformArrowDown.png" alt="">" + content + "</h1>";
			SetCookie(containerName, 'set', 30);
		} else {
			container.innerHTML = "<h1><img src="../Images/PlatformArrowRight.png" alt="">" + content + "</h1>";
			UnSetCookie(containerName);
		}
	}
	for(var i = 0; i < document.divs.length; i++) {
		var divClassName = document.divs[i];
		var matched = false;
		if(divClassName.className == className)
			   matched = true;
		if(matched) {
			
			if(divClassName != null) {
				if (divClassName.style.display == 'block') {
					divClassName.style.display = 'none';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src="../Images/DesktopNO.png" alt="" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src="../Images/iPhoneNO.png" alt="" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src="../Images/AndroidNO.png" alt="" />";
					} else {
						container.innerHTML = "<h1><img src="../Images/PlatformArrowRight.png" alt="" /> " + content + "</h1>";
					}
					UnSetCookie(containerName);
				} else {
					divClassName.style.display = 'block';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src="../Images/DesktopYES.png" alt="" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src="../Images/iPhoneYES.png" alt="" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src="../Images/AndroidYES.png" alt="" />";
					} else {
						container.innerHTML = "<h1><img src="../Images/PlatformArrowDown.png" alt="" /> " + content + "</h1>";
					}
					SetCookie(containerName, 'set', 30);
				}
			}
		}	
        }			   
    }
    function UnSetCookie(cn) {
    	SetCookie(cn,'',30);
    }

    function GetCookie(cName) {
	if (document.cookie.length > 0) {
            cStart = document.cookie.indexOf(cName + "=");
	    if(cStart != -1) {
	        cStart = cStart + cName.length + 1;
	        cEnd = document.cookie.indexOf(";", cStart);
	        if (cEnd == -1) {
	            cEnd = document.cookie.length;
	        }
	        return unescape(document.cookie.substring(cStart, cEnd));;
	    }
	}
	return "";
    }

    function SetCookie(cName, value, expireDays) {
	var exDate = new Date();
	exDate.setDate(exDate.getDate()+expireDays);
	document.cookie = cName + "=" + escape(value) + ((expireDays ==null) ? "" : ";expires=" + exDate.toGMTString()) + ";path=/";
    }

    function DocLoaded() {
	document.divs = document.getElementsByTagName('div');
	var prefDesktop = GetCookie('desktopRef');
	var prefiOS = GetCookie('iosRef');
	var prefAndroid = GetCookie('androidRef');
	var firstTime = GetCookie('FT');
	if (firstTime == null || firstTime == "" ) {
	    SetCookie('FT', 'no', 30);
	    SetCookie('desktopRef', 'set', 30)
	} else if (prefDesktop == null || prefDesktop =="") {
	    if(getElementByClass('desktopRefIMG')) {
	        ShowHideDiv('desktopRef','specific-desktop','');
	    } else {
	        ShowHideDiv('desktopRef','specific-desktop','Desktop');
	    }
	}
	if (prefiOS == null || prefiOS =="") {
	    if(getElementByClass('iosRefIMG')) {
	        ShowHideDiv('iosRef','specific-ios','');
	    } else {
	        ShowHideDiv('iosRef','specific-ios','iOS');
	    }
	}
	if (prefAndroid == null || prefAndroid =="") {
	    if(getElementByClass('androidRefIMG')) {
	        ShowHideDiv('androidRef','specific-android','');
	    } else {
	        ShowHideDiv('androidRef','specific-android','Android');
	    }
	}	
    }
    </script><!-- #TemplateEndEditable -->				<div class="nav">
					<div class="nav-prev">
						<small><a href="../Components/Networking on iOS.html"> </a></small>
						<div class="nav-left">
							&nbsp;</div>
						<div class="nav-main">
							<small><a href="../Components/Networking on iOS.html">戻る</a></small></div>
						<div class="nav-right">
							&nbsp;</div>
					</div>
					<div class="nav-next">
						<small><a href="../Components/net-UnityNetworkElements.html"> </a></small>
						<div class="nav-left">
							&nbsp;</div>
						<div class="nav-main">
							<small><a href="../Components/net-UnityNetworkElements.html">次へ</a></small></div>
						<div class="nav-right">
							&nbsp;</div>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>
