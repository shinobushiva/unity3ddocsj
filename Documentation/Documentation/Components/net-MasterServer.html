<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta charset="utf-8" />
<!-- #TemplateBeginEditable name="doctitle" -->		<title>Unity - Master Server</title>
<!-- #TemplateEndEditable -->	</head>
	<body onload="DocLoaded();">
	</body>
</html>
<link href="../Images/docs.css" rel="StyleSheet" type="text/css" />
<body onload="DocLoaded();">
	<table border="0" cellpadding="0" cellspacing="0" class="titlebar">
		<tbody>
			<tr>
				<td class="titleleft">
					<img src="../images/top/left.png" /></td>
				<td>
					<a href="../../Documentation.html"><img src="../images/top/logo.png" /></a></td>
				<td class="titlemid">
					<table>
						<tbody>
							<tr>
								<td class="doctitle">
									Master Server</td>
								<td>
									<table align="right">
										<tbody>
											<tr>
<!-- #TemplateBeginEditable name="sections-nav" -->												<td class="Components">
													<a class="scripting-anchor" href="../Manual/index.html" title="Go to Unity manual"><img border="0" class="manual" src="../images/spacer.gif" /><span class="manual-text">Manual</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
												<td class="Components">
													<a class="scripting-anchor" href="../Components/index.html" title="Go to Reference"><img border="0" class="reference" src="../images/spacer.gif" /><span class="components-text">Reference</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
												<td class="Components">
													<a class="scripting-anchor" href="../ScriptReference/index.html" title="Go to Scripting Reference"><img border="0" class="scripting" src="../images/spacer.gif" /><span class="scripting-text">Scripting &nbsp;&nbsp;</span></a></td>
<!-- #TemplateEndEditable -->											</tr>
										</tbody>
									</table>
								</td>
							</tr>
							<tr>
								<td colspan="4">
									<table class="docpath" width="100%">
										<tbody>
											<tr>
												<td>
<!-- #TemplateBeginEditable name="path" -->													<a href="../Components/index.html">Reference Manual</a> &gt; <a href="../Components/net-MasterServer.html">Master Server</a> <!-- #TemplateEndEditable --></td>
												<td class="switchlink">
<!-- #TemplateBeginEditable name="switchLink" --><!--BeginSwitchLink--><!--EndSwitchLink--><!-- #TemplateEndEditable -->												</td>
											</tr>
										</tbody>
									</table>
								</td>
							</tr>
						</tbody>
					</table>
				</td>
				<td class="titleright" width="9">
					<img src="../images/top/right.png" /></td>
			</tr>
		</tbody>
	</table>
	<div class="manual">
		<div class="main">
<!-- #TemplateBeginEditable name="unofficial translation" -->
<div id="unofficial_translation"><center><table border="1" ><tr><td  bgcolor="yellow"><center>このドキュメントは有志により翻訳されたもので、オフィシャルではありません。オリジナルのページは<a href="http://unity3d.com/support/documentation/" target="_blank">こちら</a>。<br>This document is unofficially translated by users.Please see the original document <a href="http://unity3d.com/support/documentation/" target="_blank">here</a>.<br><br>翻訳に関する修正など、ご連絡は<a href="mailto:stagesp1@gmail.com">こちら</a>まで。<br>Please send e-mail to <a href="mailto:stagesp1@gmail.com">here</a>, when you have any question about the translation.</center></td>
<td><a href="https://github.com/shinobushiva/unity3ddocsj"><img src="../Images/pencil.png"/></a><br/>編集 (GitHub)</td>
</tr></table></center></div>
<!-- #TemplateEndEditable -->

<!-- #TemplateBeginEditable name="navigation" -->			<div class="nav">
				<div class="nav-prev">
					<a href="../Components/net-NetworkLevelLoad.html"> </a>
					<div class="nav-left">
						&nbsp;</div>
					<div class="nav-main">
						<a href="../Components/net-NetworkLevelLoad.html">Previous</a></div>
					<div class="nav-right">
						&nbsp;</div>
				</div>
				<div class="nav-next">
					<a href="../Components/net-MasterServerBuild.html"> </a>
					<div class="nav-left">
						&nbsp;</div>
					<div class="nav-main">
						<a href="../Components/net-MasterServerBuild.html">Next</a></div>
					<div class="nav-right">
						&nbsp;</div>
				</div>
			</div>
<!-- #TemplateEndEditable --><!-- #TemplateBeginEditable name="title" -->			<h1>
				マスターサーバー</h1>
<!-- #TemplateEndEditable --><!-- #TemplateBeginEditable name="body" -->			<p>
				The Master Server is a meeting place for games that are actively seeking clients, and player clients who want to connect to them. Its purpose is also to hide IP address and port details and perform technical tasks around setting up network connections which might otherwise not be possible, like firewall handling and NAT punch-through.</p>
			<p class="vspace">
				Each individual running game server provide a <span class="doc-keyword">Game Type</span> to the Master Server. All games with a matching <span class="doc-keyword">Game Type</span> are gathered together so that compatible clients can easily view them. When a player connects and queries the Master Server for their matching <span class="doc-keyword">Game Type</span>, useful information on the server is displayed for the player to see. This helps the player decide which server to connect to. This includes the <span class="doc-keyword">Game Name</span>, player count and whether or not a password is needed. The two functions used to transmit this data are <a class="urllink" href="../ScriptReference/MasterServer.RegisterHost.html" rel="nofollow">MasterServer.RegisterHost()</a> for the Server, and <a class="urllink" href="../ScriptReference/MasterServer.RequestHostList.html" rel="nofollow">MasterServer.RequestHostList()</a> for the player client.</p>
			<p class="vspace">
				When calling <span class="doc-prop">RegisterHost()</span>, you need to pass three arguments - <em>gameTypeName</em> (which is the previously mentioned <span class="doc-keyword">Game Type</span>), <em>gameName</em> and <em>comment</em> - for the host being registered. <span class="doc-prop">RequestHostList()</span> takes as an argument the <em>gameTypeName</em> of the hosts you are interested in connecting to. All the registered hosts of that type will then be sent to the requesting client. This is an asynchronous operation and the actual host list can be retrieved with <span class="doc-prop">PollHostList()</span> which returns the list when it has arrived.</p>
			<p class="vspace">
				The NAT punchthrough portion of the Master Server is actually done by a separate entity called the <span class="doc-keyword">Facilitator</span>. The central Unity Master Server is also running a Facilitator in addition to being a game lobby so it is OK to think of these functionalities as simply Master Server functionalities in that context.</p>
			<p class="vspace">
				The <span class="doc-keyword">Game Type</span> you set for your game should be unique for your game. This is to prevent clients running a completely different game from seeing your servers and trying to connect to them. So don&#39;t use &quot;Game1&quot; or anything generic like that as the <span class="doc-prop">gameTypeName</span>. Be specific and unique. If you have different versions of your game out, you could use the comment field to relay that information. That way the client will know if their version is incompatible with some servers in the host list. The comment field can also be used to relay any information you desire. It is a binary data field and can store objects, you just need to cast them properly yourself.</p>
			<p class="vspace">
				More advanced functionality can be done by using the comment field and customizing the Master Server so that it will use that information itself. For example you could reserve the first 10 bytes of the comment field for a password and then extract the password in the Master Server when it receives the host update. It can compare and reject the host update if appropriate (password check fails). Of course this would require editing of the Master Server source code itself, but this can be downloaded and modified. For more information about this, skip down the page to the <a href="#advanced">Advanced Section</a>.</p>
			<div class="vspace">
				&nbsp;</div>
			<h2>
				Registering a game</h2>
			<p>
				Before registering a game it is important to set the NAT functionality properly by setting useNat parameter for <a class="urllink" href="../ScriptReference/Network.InitializeServer.html" rel="nofollow">Network.InitializeServer</a> to true or false depending on the networking capabilities of the host. The user hosting the game <em>should</em> know if he has a NAT address or not and if the game port is connectable on the public internet, so before hosting the game he will indicate if NAT assistance is needed or not.</p>
			<p class="vspace">
				A server might be started with code similar to this:</p>
			<div class="vspace">
				&nbsp;</div>
			<pre class="codelisting">
			function OnGUI() {
	if (GUILayout.Button (&quot;Start Server&quot;))
	{
		// Use NAT punchthrough if no public IP present
		Network.InitializeServer(32, 25002, !Network.HavePublicAddress());
		MasterServer.RegisterHost(&quot;MyUniqueGameType&quot;, &quot;JohnDoes game&quot;, &quot;l33t game for all&quot;);
	}
}
</pre>
			<p class="vspace">
				Here we just decide if NAT punchthrough is needed based on if the machine has a public address or not. There is a more involved function available called <a class="urllink" href="../ScriptReference/Network.TestConnection.html" rel="nofollow">Network.TestConnection()</a> which can tell you if the host machine can do NAT or not. It also does connectivity testing for public IP addresses to see if a firewall is blocking the game port. Machines which have public IP addresses always pass the NAT test but if the test fails then the host will <b>NOT</b> be connectable to NAT clients. In such a case the user needs to be informed that in order to host a game he needs to set up port forwarding if possible. Usually people with cheap broadband connections will have a NAT address and not be able to set up port forwarding (as they don&#39;t have a personal public IP address at all). In these cases, if the NAT test fails, the user should be informed that running a server is inadvisable as no one but clients on the same local network will be able to connect.</p>
			<p class="vspace">
				If a host enables NAT functionality without needing it, no harm is done and it will still be connectable, however, client which cannot do NAT punchthrough will think they cannot connect to him as he has NAT enabled.</p>
			<div class="vspace">
				&nbsp;</div>
			<h3>
				Connecting to a game</h3>
			<p>
				The host information, <span class="doc-prop">HostData</span>, object sent during host registrations or queries contains the following information:</p>
			<table width="100%">
				<tbody>
					<tr>
						<td align="left">
							boolean</td>
						<td align="left">
							<span class="doc-prop">useNat</span></td>
						<td align="left">
							Indicates if the host uses NAT punchthrough.</td>
					</tr>
					<tr>
						<td align="left">
							String</td>
						<td align="left">
							<span class="doc-prop">gameType</span></td>
						<td align="left">
							The game type of the host.</td>
					</tr>
					<tr>
						<td align="left">
							String</td>
						<td align="left">
							<span class="doc-prop">gameName</span></td>
						<td>
							The game name of the host.</td>
					</tr>
					<tr>
						<td align="left">
							int</td>
						<td align="left">
							<span class="doc-prop">connectedPlayers</span></td>
						<td>
							The amount of currently connected players/clients.</td>
					</tr>
					<tr>
						<td align="left">
							int</td>
						<td align="left">
							<span class="doc-prop">playerLimit</span></td>
						<td>
							The maximum amount of allowed concurrent players/clients.</td>
					</tr>
					<tr>
						<td align="left">
							String[]</td>
						<td align="left">
							<span class="doc-prop">IP</span></td>
						<td>
							The internal IP address of the host. On a server with a public address the external and internal addresses are the same. This is an array as when connecting internally, all the IP addresses associated with all the active interfaces of the machine need to be checked.</td>
					</tr>
					<tr>
						<td align="left">
							int</td>
						<td align="left">
							<span class="doc-prop">port</span></td>
						<td>
							The port of the host.</td>
					</tr>
					<tr>
						<td align="left">
							boolean</td>
						<td align="left">
							<span class="doc-prop">passwordProtected</span></td>
						<td>
							Indicates if you need to supply a password to be able to connect to this host.</td>
					</tr>
					<tr>
						<td align="left">
							String</td>
						<td align="left">
							<span class="doc-prop">comment</span></td>
						<td>
							Any comment which was set during host registration.</td>
					</tr>
					<tr>
						<td align="left">
							String</td>
						<td align="left">
							<span class="doc-prop">guid</span></td>
						<td>
							The network GUID of the host. This is needed when connecting using NAT punchthrough.</td>
					</tr>
				</tbody>
			</table>
			<p class="vspace">
				This information can be used by clients to see the connection capabilities of the hosts. When NAT is enabled you need to use the GUID of the host when connecting. This is automatically handled for you when you connect to the HostData struct directly. The connect routine might look something like this:</p>
			<div class="vspace">
				&nbsp;</div>
			<pre class="codelisting">
			function Awake() {
	MasterServer.RequestHostList(&quot;MadBubbleSmashGame&quot;);
}

function OnGUI() {
	var data : HostData[] = MasterServer.PollHostList();
	// Go through all the hosts in the host list
	for (var element in data)
	{
		GUILayout.BeginHorizontal();	
		var name = element.gameName + &quot; &quot; + element.connectedPlayers + &quot; / &quot; + element.playerLimit;
		GUILayout.Label(name);	
		GUILayout.Space(5);
		var hostInfo;
		hostInfo = &quot;[&quot;;
		for (var host in element.ip)
			hostInfo = hostInfo + host + &quot;:&quot; + element.port + &quot; &quot;;
		hostInfo = hostInfo + &quot;]&quot;;
		GUILayout.Label(hostInfo);	
		GUILayout.Space(5);
		GUILayout.Label(element.comment);
		GUILayout.Space(5);
		GUILayout.FlexibleSpace();
		if (GUILayout.Button(&quot;Connect&quot;))
		{
			// Connect to HostData struct, internally the correct method is used (GUID when using NAT).
			Network.Connect(element);			
		}
		GUILayout.EndHorizontal();	
	}
}
</pre>
			<p class="vspace">
				This example code prints out all the relevant information of the hosts returned by the Master Server. Other useful data like ping information or geographic location of hosts can be added to this.</p>
			<div class="vspace">
				&nbsp;</div>
			<h2>
				NAT punchthrough</h2>
			<p>
				Bear in mind that NAT punchthrough will not work 100% of the time so certain machines are not suited to run as servers as some clients can connect to them and certain client might have trouble connecting to any NAT server.</p>
			<p class="vspace">
				By default NAT punch through is done with the help of the Master Server but this functionality does not need to rely on the Master Server. The Facilitator is the one who is actually used for the NAT punchthrough routine. If two machines are connected to the Facilitator, one can directly connect to the other if as long as it uses the external IP and port. The Master Server is used to provide this external IP and port information which is otherwise hard to determine. That is why the Master Server and Facilitator are so tightly integrated. The Master Server and Facilitator have the same IP address by default, to change either one use the <a class="urllink" href="../ScriptReference/MasterServer-ipAddress.html" rel="nofollow">MasterServer.ipAddress</a>, <a class="urllink" href="../ScriptReference/MasterServer-port.html" rel="nofollow">MasterServer.port</a>, <a class="urllink" href="../ScriptReference/Network-natFacilitatorIP.html" rel="nofollow">Network.natFacilitatorIP</a> and <a class="urllink" href="../ScriptReference/Network-natFacilitatorPort.html" rel="nofollow">Network.natFacilitatorPort</a></p>
			<p class="vspace">
				<a id="advanced" name="advanced"></a></p>
			<h2>
				Advanced</h2>
			<p>
				The Master Server is a completely separate entity from the Unity editor itself. It can be deployed on Windows, Linux and Mac OS, and anyone can have their own Master Server. Unity Technologies has a dedicated Master Server available for anyone to use which is the default server used.</p>
			<p class="vspace">
				There might be cases where you want do modify how the Master Server handles information and how it communicates. Maybe you need to do some optimizations of how the Master Server handles host data information from the individual game servers. Maybe you need to limit how many hosts the clients will receive when they request the host list, either numerically or through some kind of filter like location. This would mostly be bandwidth optimizations but anything can be done as long as it communicates properly with the Unity player.</p>
			<p class="vspace">
				To perform any of these modifications, you must build, deploy, and host your own Master Server. Information about how to do this can be found on the <a href="../Components/net-MasterServerBuild.html">Master Server Build page</a>.</p>
			<p>
				&nbsp;</p>
			<small>Page last updated: 2010-09-25</small>
			<p>
				&nbsp;</p>
<script type="text/javascript">


    var allHTMLTags = new Array();
    document.divs = new Array();

    function getElementByClass(theClass) {

	    var allHTMLTags=document.getElementsByTagName("*");

	    for (var i=0; i<allHTMLTags.length; i++) {

		    if (allHTMLTags[i].className==theClass) {
			    return true;
		    }
	    }
	    return false;
    }

    function ShowHideDiv(containerName, className, content){
	var container = document.getElementById(containerName);
	if(container == null)
		return;
	if(content == '') {//In case there are no divs in the page we still can change the icons.
		if(containerName == 'desktopRef') {
			if(container.innerHTML == "<img src="../Images/DesktopNO.png" alt="">") {
				container.innerHTML = "<img src="../Images/DesktopYES.png" alt="">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src="../Images/DesktopNO.png" alt="">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'iosRef') {
			if(container.innerHTML == "<img src="../Images/iPhoneNO.png" alt="">") {
				container.innerHTML = "<img src="../Images/iPhoneYES.png" alt="">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src="../Images/iPhoneNO.png" alt="">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'androidRef') {
			if(container.innerHTML == "<img src="../Images/AndroidNO.png" alt="">") {
				container.innerHTML = "<img src="../Images/AndroidYES.png" alt="">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src="../Images/AndroidNO.png" alt="">";
				UnSetCookie(containerName);
			}	
		}
	} else {
		if(container.innerHTML == "<h1><img src="../Images/PlatformArrowRight.png" alt=""> " + content + "</h1>") {
		container.innerHTML = "<h1><img src="../Images/PlatformArrowDown.png" alt="">" + content + "</h1>";
			SetCookie(containerName, 'set', 30);
		} else {
			container.innerHTML = "<h1><img src="../Images/PlatformArrowRight.png" alt="">" + content + "</h1>";
			UnSetCookie(containerName);
		}
	}
	for(var i = 0; i < document.divs.length; i++) {
		var divClassName = document.divs[i];
		var matched = false;
		if(divClassName.className == className)
			   matched = true;
		if(matched) {
			
			if(divClassName != null) {
				if (divClassName.style.display == 'block') {
					divClassName.style.display = 'none';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src="../Images/DesktopNO.png" alt="" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src="../Images/iPhoneNO.png" alt="" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src="../Images/AndroidNO.png" alt="" />";
					} else {
						container.innerHTML = "<h1><img src="../Images/PlatformArrowRight.png" alt="" /> " + content + "</h1>";
					}
					UnSetCookie(containerName);
				} else {
					divClassName.style.display = 'block';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src="../Images/DesktopYES.png" alt="" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src="../Images/iPhoneYES.png" alt="" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src="../Images/AndroidYES.png" alt="" />";
					} else {
						container.innerHTML = "<h1><img src="../Images/PlatformArrowDown.png" alt="" /> " + content + "</h1>";
					}
					SetCookie(containerName, 'set', 30);
				}
			}
		}	
        }			   
    }
    function UnSetCookie(cn) {
    	SetCookie(cn,'',30);
    }

    function GetCookie(cName) {
	if (document.cookie.length > 0) {
            cStart = document.cookie.indexOf(cName + "=");
	    if(cStart != -1) {
	        cStart = cStart + cName.length + 1;
	        cEnd = document.cookie.indexOf(";", cStart);
	        if (cEnd == -1) {
	            cEnd = document.cookie.length;
	        }
	        return unescape(document.cookie.substring(cStart, cEnd));;
	    }
	}
	return "";
    }

    function SetCookie(cName, value, expireDays) {
	var exDate = new Date();
	exDate.setDate(exDate.getDate()+expireDays);
	document.cookie = cName + "=" + escape(value) + ((expireDays ==null) ? "" : ";expires=" + exDate.toGMTString()) + ";path=/";
    }

    function DocLoaded() {
	document.divs = document.getElementsByTagName('div');
	var prefDesktop = GetCookie('desktopRef');
	var prefiOS = GetCookie('iosRef');
	var prefAndroid = GetCookie('androidRef');
	var firstTime = GetCookie('FT');
	if (firstTime == null || firstTime == "" ) {
	    SetCookie('FT', 'no', 30);
	    SetCookie('desktopRef', 'set', 30)
	} else if (prefDesktop == null || prefDesktop =="") {
	    if(getElementByClass('desktopRefIMG')) {
	        ShowHideDiv('desktopRef','specific-desktop','');
	    } else {
	        ShowHideDiv('desktopRef','specific-desktop','Desktop');
	    }
	}
	if (prefiOS == null || prefiOS =="") {
	    if(getElementByClass('iosRefIMG')) {
	        ShowHideDiv('iosRef','specific-ios','');
	    } else {
	        ShowHideDiv('iosRef','specific-ios','iOS');
	    }
	}
	if (prefAndroid == null || prefAndroid =="") {
	    if(getElementByClass('androidRefIMG')) {
	        ShowHideDiv('androidRef','specific-android','');
	    } else {
	        ShowHideDiv('androidRef','specific-android','Android');
	    }
	}	
    }
    </script><!-- #TemplateEndEditable -->			<div class="nav">
				<div class="nav-prev">
					<small><a href="../Components/net-NetworkLevelLoad.html"> </a></small>
					<div class="nav-left">
						&nbsp;</div>
					<div class="nav-main">
						<small><a href="../Components/net-NetworkLevelLoad.html">Previous</a></small></div>
					<div class="nav-right">
						&nbsp;</div>
				</div>
				<div class="nav-next">
					<small><a href="../Components/net-MasterServerBuild.html"> </a></small>
					<div class="nav-left">
						&nbsp;</div>
					<div class="nav-main">
						<small><a href="../Components/net-MasterServerBuild.html">Next</a></small></div>
					<div class="nav-right">
						&nbsp;</div>
				</div>
			</div>
		</div>
	</div>
</body>
