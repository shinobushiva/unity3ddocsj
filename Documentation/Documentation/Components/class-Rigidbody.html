<!-- #BeginTemplate "/Templates/manual-page.dwt" --><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8">
	<!-- #TemplateBeginEditable name="doctitle" -->
		<title>Unity - Rigidbody</title>
	<!-- #TemplateEndEditable -->
</head>
<link rel="StyleSheet"  href="../Images/docs.css" type="text/css" />
<body onLoad="DocLoaded();">
<table class="titlebar" cellpadding=0 cellspacing=0 border=0><tr>
	<td class="titleleft"><img src="../images/top/left.png"></td>
	<td><a href="../../Documentation.html"><img src="../images/top/logo.png"></a></td>
	<td class="titlemid">
		<table><tr>
			<td class="doctitle">Rigidbody</td>
			<td><table align="right"><tr>
			<!-- #TemplateBeginEditable name="sections-nav" -->
			<td class="Components"><a href="../Manual/index.html" title="Go to Unity manual" class="scripting-anchor"><img src="../images/spacer.gif" class="manual" border="0"><span class="manual-text">Manual</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td class="Components"><a href="../Components/index.html" title="Go to Reference" class="scripting-anchor"><img src="../images/spacer.gif" class="reference" border="0"><span class="components-text">Reference</span></a><span class="docs-navigation">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td class="Components"><a href="../ScriptReference/index.html" title="Go to Scripting Reference" class="scripting-anchor"><img src="../images/spacer.gif" class="scripting" border="0"><span class="scripting-text">Scripting &nbsp;&nbsp;</span></a></td>
			<!-- #TemplateEndEditable -->	
			</tr></table></td>
		</tr><tr>
			<td colspan="4">
				<table width="100%" class="docpath"><tr><td >
		<!-- #TemplateBeginEditable name="path" -->
					<a href="../Components/index.html">Reference Manual</a> &gt; <a href="../Components/Components.html">Components</a> &gt; <a href="../Components/comp-DynamicsGroup.html">Physics Components</a> &gt; <a href="../Components/class-Rigidbody.html">Rigidbody</a>
		<!-- #TemplateEndEditable -->	
				</td>
				</td><td class="switchlink">
					<!-- #TemplateBeginEditable name="switchLink" -->
					<!--BeginSwitchLink--><!--EndSwitchLink-->
					<!-- #TemplateEndEditable -->	
				</td></tr></table>
			</td>
		</tr></table>
	</td>
	<td class="titleright" width="9"><img src="../images/top/right.png"></td>
</tr></table>
<div class="manual">
	<div class="main">

<!-- #TemplateBeginEditable name="unofficial translation" -->
<div id="unofficial_translation"><center><table border="1" ><tr><td  bgcolor="yellow"><center>このドキュメントは有志により翻訳されたもので、オフィシャルではありません。オリジナルのページは<a href="http://unity3d.com/support/documentation/" target="_blank">こちら</a>。<br>This document is unofficially translated by users.Please see the original document <a href="http://unity3d.com/support/documentation/" target="_blank">here</a>.<br><br>翻訳に関する修正など、ご連絡は<a href="mailto:stagesp1@gmail.com">こちら</a>まで。<br>Please send e-mail to <a href="mailto:stagesp1@gmail.com">here</a>, when you have any question about the translation.</center></td>
<td><a href="https://github.com/shinobushiva/unity3ddocsj"><img src="../Images/pencil.png"/></a><br/>編集 (GitHub)</td>
</tr></table></center></div>
<!-- #TemplateEndEditable -->


		<!-- #TemplateBeginEditable name="navigation" -->
		<div class="nav">
		<div class="nav-prev">
			<a href='../Components/class-PhysicMaterial.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Previous</div>
				<div class="nav-right"></div>
			</a>
		</div>
	
		<div class="nav-next">
			<a href='../Components/class-SphereCollider.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Next</div>
				<div class="nav-right"></div>
			</a>
		</div>
	</div>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="title" -->
			<h1>Rigidbody</h1>
		<!-- #TemplateEndEditable -->	
		<!-- #TemplateBeginEditable name="body" -->
			
<p><span class='doc-keyword'>Rigidbodies</span> enable your <span class='doc-keyword'>GameObjects</span> to act under the control of physics. The Rigidbody can receive forces and torque to make your objects move in a realistic way.  Any GameObject must contain a Rigidbody to be influenced by gravity, act under added forces via scripting, or interact with other objects through the NVIDIA PhysX physics engine.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/class-Rigidbody-0.jpg' /><br /><em>Rigidbodies allow GameObjects to act under physical influence</em></div>
<div class='vspace'></div><h2>Properties</h2>
<table width='100%'><tr class='tableheader'><td  class='prop'></td><td class='function'></td></tr>
<tr ><td  align='left'><span class='doc-prop'>Mass</span></td><td  align='left'>The weight of the object in kilograms. It is recommended to make masses not more or less than 100 times that of other Rigidbodies.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Drag</span></td><td  align='left'>How much air resistance affects the object when moving from forces. 0 means no air resistance, and infinity makes the object stop moving immediately.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Angular Drag</span></td><td  align='left'>How much air resistance affects the object when rotating from torque. 0 means no air resistance, and infinity makes the object stop rotating immediately.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Use Gravity</span></td><td  align='left'>If enabled, the object is affected by gravity.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Is Kinematic</span></td><td  align='left'>If enabled, the object will not be driven by the physics engine, and can only be manipulated by its <span class='doc-keyword'>Transform</span>. This is useful for moving platforms or if you want to animate a Rigidbody that has a <span class='doc-keyword'>HingeJoint</span> attached.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Interpolate</span></td><td  align='left'>Try one of the options only if you are seeing jerkiness in your Rigidbody's movement.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>None</span></span></td><td  align='left'>No Interpolation is applied.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Interpolate</span></span></td><td  align='left'>Transform is smoothed based on the Transform of the previous frame.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Extrapolate</span></span></td><td  align='left'>Transform is smoothed based on the estimated Transform of the next frame.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Freeze Rotation</span></td><td  align='left'>If enabled, this GameObject will never rotate based on collisions or forces added via script -- it will only rotate when using <span class='doc-prop'>transform.Rotate()</span>.</td></tr>
<tr ><td  align='left'><span class='doc-prop'>Collision Detection</span></td><td  align='left'>Used to prevent fast moving objects from passing through other objects without detecting collisions.</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Discrete</span></span></td><td  align='left'>Used for normal collisions (This is the default value).</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Continuous</span></span></td><td  align='left'>Used for objects which the Continuous Dynamic detection needs to collide with.(This has a big impact on physics performance, leave it set to <span class='doc-keyword'>Discrete</span>, if you don't have issues with collisions of fast objects).</td></tr>
<tr ><td  align='left'><span  style='padding-left: 1.5em;'><span class='doc-prop'>Continuous Dynamic</span></span></td><td >Used for fast moving objects.</td></tr>
</table>
<div class='vspace'></div><h2>Details</h2>
<p>Rigidbodies allow your GameObjects to act under control of the physics engine.  This opens the gateway to realistic collisions, varied types of joints, and other very cool behaviors.  Manipulating your GameObjects by adding forces to a Rigidbody creates a very different feel and look than adjusting the Transform <span class='doc-keyword'>Component</span> directly.  Generally, you shouldn't manipulate the Rigidbody and the Transform of the same GameObject - only one or the other.
</p>
<p class='vspace'>The biggest difference between manipulating the Transform versus the Rigidbody is the use of forces.  Rigidbodies can receive forces and torque, but Transforms cannot.  Transforms can be translated and rotated, but this is not the same as using physics. You'll notice the distinct difference when you try it for yourself.  Adding forces/torque to the Rigidbody will actually change the object's position and rotation of the Transform component.  This is why you should only be using one or the other.  Changing the Transform while using physics could cause problems with collisions and other calculations.
</p>
<p class='vspace'>Rigidbodies must be explicitly added to your GameObject before they will be affected by the physics engine.  You can add a Rigidbody to your selected object from <span class='doc-prop'>Components-&gt;Physics-&gt;Rigidbody</span> in the menubar. Now your object is physics-ready; it will fall under gravity and can receive forces via scripting, but you may need to add a <span class='doc-keyword'>Collider</span> or a Joint to get it to behave exactly how you want.
</p>
<div class='vspace'></div><h3>Parenting</h3>
<p>When an object is under physics control, it moves semi-independently of the way its transform parents move. If you move any parents, they will pull the Rigidbody child along with them. However, the Rigidbodies will still fall down due to gravity and react to collision events.
</p>
<div class='vspace'></div><h3>Scripting</h3>
<p>To control your Rigidbodies, you will primarily use scripts to add forces or torque. You do this by calling <span class='doc-prop'><a class='urllink' href='../ScriptReference/Rigidbody.AddForce.html' rel='nofollow'>AddForce()</a></span> and <span class='doc-prop'><a class='urllink' href='../ScriptReference/Rigidbody.AddTorque.html' rel='nofollow'>AddTorque()</a></span> on the object's Rigidbody.  Remember that you shouldn't be directly altering the object's Transform when you are using physics.
</p>
<div class='vspace'></div><h3>Animation</h3>
<p>For some situations, mainly creating ragdoll effects, it is neccessary to switch control of the object between animations and physics. For this purpose Rigidbodies can be marked <span class='doc-prop'><a class='urllink' href='../ScriptReference/Rigidbody-isKinematic.html' rel='nofollow'>isKinematic</a></span>. While the Rigidbody is marked <span class='doc-prop'>isKinematic</span>, it will not be affected by collisions, forces, or any other part of physX. This means that you will have to control the object by manipulating the <a href="../Components/class-Transform.html">Transform</a> component directly.  Kinematic Rigidbodies will affect other objects, but they themselves will not be affected by physics. For example, Joints which are attached to Kinematic objects will constrain any other Rigidbodies attached to them and Kinematic Rigidbodies will affect other Rigidbodies through collisions.
</p>
<div class='vspace'></div><h3>Colliders</h3>
<p>Colliders are another kind of component that must be added alongside the Rigidbody in order to allow collisions to occur.  If two Rigidbodies bump into each other, the physics engine will not calculate a collision unless both objects also have a Collider attached.  Collider-less Rigidbodies will simply pass through each other during physics simulation.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/class-Rigidbody-1.jpg' /><br /><em>Colliders define the physical boundaries of a Rigidbody</em></div>
<p class='vspace'>Add a Collider with the <span class='doc-prop'>Component-&gt;Physics</span> menu.  View the Component Reference page of any individual Collider for more specific information:
</p><ul><li><a href="../Components/class-BoxCollider.html">Box Collider</a> - primitive shape of a cube
</li><li><a href="../Components/class-SphereCollider.html">Sphere Collider</a> - primitive shape of a sphere
</li><li><a href="../Components/class-CapsuleCollider.html">Capsule Collider</a> - primitive shape of a capsule
</li><li><a href="../Components/class-MeshCollider.html">Mesh Collider</a> - creates a collider from the object's mesh, cannot collide with another Mesh Collider
</li><li><a href="../Components/class-WheelCollider.html">Wheel Collider</a> - specifically for creating cars or other moving vehicles
</li></ul><div class='vspace'></div><h3>Compound Colliders</h3>
<p>Compound Colliders are combinations of primitive Colliders, collectively acting as a single Collider.  They come in handy when you have a complex mesh to use in collisions but cannot use a <span class='doc-keyword'>Mesh Collider</span>.  To create a Compound Collider, create child objects of your colliding object, then add a primitive Collider to each child object.  This allows you to position, rotate, and scale each Collider easily and independently of one another.
</p>
<div class='vspace'></div><div><img class='figure' src='../Images/manual/class-Rigidbody-2.jpg' /><br /><em>A real-world Compound Collider setup</em></div>
<p class='vspace'>In the above picture, the environment has a Mesh Collider attached.  Mesh Colliders work the best for terrain or environments made from irregular shapes. The <span class='doc-menu'>gun_model</span> GameObject has a Rigidbody attached, and multiple primitive Colliders as child GameObjects. When the Rigidbody parent is moved around by forces, the child Colliders move along with it. The primitive Colliders will collide with the environment's Mesh Collider, and the parent Rigidbody will alter the way it moves based on forces being applied to it and how its child Colliders interact with other Colliders in the Scene.
</p>
<p class='vspace'>Mesh Colliders can't normally collide with each other.  If a Mesh Collider is marked as <span class='doc-prop'>Convex</span>, then it can collide with another Mesh Collider.  The typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
</p>
<div class='vspace'></div><h3>Continuous Collision Detection</h3>
<p>Continuous collision detection is a feature to prevent fast-moving colliders from passing each other. This may happen when using normal (<span class='doc-prop'>Discrete</span>) collision detection, when an object is one side of a collider in one frame, and already passed the collider in the next frame. To solve this, you can enable continuous collision detection on the rigidbody of the fast-moving object. Set the collision detection mode to <span class='doc-prop'>Continuous</span> to prevent the rigidbody from passing through any static (ie, non-rigidbody) MeshColliders. Set it to <span class='doc-prop'>Continuous Dynamic</span> to also prevent the rigidbody from passing through any other supported rigidbodies with collision detection mode set to <span class='doc-prop'>Continuous</span> or <span class='doc-prop'>Continuous Dynamic</span>. 
Continuous collision detection is supported for Box-, Sphere- and CapsuleColliders.
</p>
<div class='vspace'></div><h2>Use the right size</h2>
<p>The size of the your GameObject's mesh is much more important than the mass of the Rigidbody.  If you find that your Rigidbody is not behaving exactly how you expect - it moves slowly, floats, or doesn't collide correctly - consider adjusting the scale of your mesh asset.  Unity's default unit scale is 1 unit = 1 meter, so the scale of your imported mesh is maintained, and applied to physics calculations.  For example, a crumbling skyscraper is going to fall apart very differently than a tower made of toy blocks, so objects of different sizes should be modeled to accurate scale.
</p>
<p class='vspace'>If you are modeling a human make sure he is around 2 meters tall in Unity. To check if your object has the right size compare it to the default cube. You can create a cube using <span class='doc-menu'>GameObject-&gt;Create Other-&gt;Cube</span>. The cube's height will be exactly 1 meter, so your human should be twice as tall.
</p>
<p class='vspace'>If you aren't able to adjust the mesh itself, you can change the uniform scale of a particular mesh asset by selecting it in <span class='doc-keyword'>Project View</span> and choosing <span class='doc-menu'>Assets-&gt;Import Settings...</span> from the menubar.  Here, you can change the scale and re-import your mesh.
</p>
<p class='vspace'>If your game requires that your GameObject needs to be instantiated at different scales, it is okay to adjust the values of your Transform's scale axes.  The downside is that the physics simulation must do more work at the time the object is instantiated, and could cause a performance drop in your game.  This isn't a terrible loss, but it is not as efficient as finalizing your scale with the other two options.  Also keep in mind that non-uniform scales can create undesirable behaviors when Parenting is used.  For these reasons it is always optimal to create your object at the correct scale in your modeling application.
</p>
<div class='vspace'></div><h2>Hints</h2>
<ul><li>The relative <span class='doc-prop'>Mass</span> of two Rigidbodies determines how they react when they collide with each other.
</li><li>Making one Rigidbody have greater <span class='doc-prop'>Mass</span> than another does not make it fall faster in free fall. Use <span class='doc-prop'>Drag</span> for that.
</li><li>A low <span class='doc-prop'>Drag</span> value makes an object seem heavy. A high one makes it seem light. Typical values for <span class='doc-prop'>Drag</span> are between .001 (solid block of metal) and 10 (feather).
</li><li>If you are directly manipulating the Transform component of your object but still want physics, attach a Rigidbody and make it Kinematic.
</li><li>If you are moving a GameObject through its Transform component but you want to receive Collision/Trigger messages, you must attach a Rigidbody to the object that is moving.
</li></ul>
</p><small>Page last updated: 2010-09-03</p>
    <script type="text/javascript">


    var allHTMLTags = new Array();
    document.divs = new Array();

    function getElementByClass(theClass) {

	    var allHTMLTags=document.getElementsByTagName("*");

	    for (var i=0; i<allHTMLTags.length; i++) {

		    if (allHTMLTags[i].className==theClass) {
			    return true;
		    }
	    }
	    return false;
    }

    function ShowHideDiv(containerName, className, content){
	var container = document.getElementById(containerName);
	if(container == null)
		return;
	if(content == '') {//In case there are no divs in the page we still can change the icons.
		if(containerName == 'desktopRef') {
			if(container.innerHTML == "<img src=\"../Images/DesktopNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/DesktopYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/DesktopNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'iosRef') {
			if(container.innerHTML == "<img src=\"../Images/iPhoneNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/iPhoneYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/iPhoneNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}
		}
		if(containerName == 'androidRef') {
			if(container.innerHTML == "<img src=\"../Images/AndroidNO.png\" alt=\"\">") {
				container.innerHTML = "<img src=\"../Images/AndroidYES.png\" alt=\"\">";
				SetCookie(containerName, 'set', 30);
			} else {
				container.innerHTML = "<img src=\"../Images/AndroidNO.png\" alt=\"\">";
				UnSetCookie(containerName);
			}	
		}
	} else {
		if(container.innerHTML == "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\"> " + content + "</h1>") {
		container.innerHTML = "<h1><img src=\"../Images/PlatformArrowDown.png\" alt=\"\">" + content + "</h1>";
			SetCookie(containerName, 'set', 30);
		} else {
			container.innerHTML = "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\">" + content + "</h1>";
			UnSetCookie(containerName);
		}
	}
	for(var i = 0; i < document.divs.length; i++) {
		var divClassName = document.divs[i];
		var matched = false;
		if(divClassName.className == className)
			   matched = true;
		if(matched) {
			
			if(divClassName != null) {
				if (divClassName.style.display == 'block') {
					divClassName.style.display = 'none';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src=\"../Images/DesktopNO.png\" alt=\"\" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src=\"../Images/iPhoneNO.png\" alt=\"\" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src=\"../Images/AndroidNO.png\" alt=\"\" />";
					} else {
						container.innerHTML = "<h1><img src=\"../Images/PlatformArrowRight.png\" alt=\"\" /> " + content + "</h1>";
					}
					UnSetCookie(containerName);
				} else {
					divClassName.style.display = 'block';
					if(content == '') {
						if(className == 'specific-desktop')
							container.innerHTML = "<img src=\"../Images/DesktopYES.png\" alt=\"\" />";
						if(className == 'specific-ios')
							container.innerHTML = "<img src=\"../Images/iPhoneYES.png\" alt=\"\" />";
						if(className == 'specific-android')
							container.innerHTML = "<img src=\"../Images/AndroidYES.png\" alt=\"\" />";
					} else {
						container.innerHTML = "<h1><img src=\"../Images/PlatformArrowDown.png\" alt=\"\" /> " + content + "</h1>";
					}
					SetCookie(containerName, 'set', 30);
				}
			}
		}	
        }			   
    }
    function UnSetCookie(cn) {
    	SetCookie(cn,'',30);
    }

    function GetCookie(cName) {
	if (document.cookie.length > 0) {
            cStart = document.cookie.indexOf(cName + "=");
	    if(cStart != -1) {
	        cStart = cStart + cName.length + 1;
	        cEnd = document.cookie.indexOf(";", cStart);
	        if (cEnd == -1) {
	            cEnd = document.cookie.length;
	        }
	        return unescape(document.cookie.substring(cStart, cEnd));;
	    }
	}
	return "";
    }

    function SetCookie(cName, value, expireDays) {
	var exDate = new Date();
	exDate.setDate(exDate.getDate()+expireDays);
	document.cookie = cName + "=" + escape(value) + ((expireDays ==null) ? "" : ";expires=" + exDate.toGMTString()) + ";path=/";
    }

    function DocLoaded() {
	document.divs = document.getElementsByTagName('div');
	var prefDesktop = GetCookie('desktopRef');
	var prefiOS = GetCookie('iosRef');
	var prefAndroid = GetCookie('androidRef');
	var firstTime = GetCookie('FT');
	if (firstTime == null || firstTime == "" ) {
	    SetCookie('FT', 'no', 30);
	    SetCookie('desktopRef', 'set', 30)
	} else if (prefDesktop == null || prefDesktop =="") {
	    if(getElementByClass('desktopRefIMG')) {
	        ShowHideDiv('desktopRef','specific-desktop','');
	    } else {
	        ShowHideDiv('desktopRef','specific-desktop','Desktop');
	    }
	}
	if (prefiOS == null || prefiOS =="") {
	    if(getElementByClass('iosRefIMG')) {
	        ShowHideDiv('iosRef','specific-ios','');
	    } else {
	        ShowHideDiv('iosRef','specific-ios','iOS');
	    }
	}
	if (prefAndroid == null || prefAndroid =="") {
	    if(getElementByClass('androidRefIMG')) {
	        ShowHideDiv('androidRef','specific-android','');
	    } else {
	        ShowHideDiv('androidRef','specific-android','Android');
	    }
	}	
    }
    </script>
    
		<!-- #TemplateEndEditable -->	

		<div class="nav">
		<div class="nav-prev">
			<a href='../Components/class-PhysicMaterial.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Previous</div>
				<div class="nav-right"></div>
			</a>
		</div>
	
		<div class="nav-next">
			<a href='../Components/class-SphereCollider.html'>
				<div class="nav-left"></div>
				<div class="nav-main">Next</div>
				<div class="nav-right"></div>
			</a>
		</div>
	</div>
	</div>
</div>
</body></html>
<!-- #EndTemplate -->
